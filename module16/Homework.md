# Homework 16

## Task

Напишите структуру, которая будет реализовывать клиент для клиента банковского приложения. 
Этот клиент должен реализовывать следующий интерфейс:
```go
type BankClient interface {
	// Deposit deposits given amount to clients account
	Deposit(amount int)
	
	// Withdrawal withdraws given amount from clients account. 
	// return error if clients balance less the withdrawal amount 
	Withdrawal(amount int) error
	
	// Balance returns clients balance
	Balance() int
}
```

Используя этот клиент, создайте консольное приложение, которое:

1. В момент старта запускает 10 горутин, каждая из которых с промежутком от 0.5 секунд до 1 секунды зачисляет на счёт 
клиента случайную сумму от 1 до 10.
2. Так же запускается 5 горутин, которые с промежутком 0.5 секунд до 1 секунды снимают с клиента случайную сумму 
от 1 до 5. Если снятие невозможно, в консоль выводится сообщение об ошибке, и приложение продолжает работу.
3. Если пользователь введет в консоль слово balance — приложение выведет в консоль текущий баланс клиента.
4. deposit — запрашивается сумма (целое число) — которая добавляется на счёт пользователя
5. withdrawal — запрашивается сумма (целое число) — которая выводится со счёта пользователя.
Если запрашиваемая сумма больше текущего баланса пользователя, то пользователю должно быть показано сообщение о том, 
что его баланс недостаточен (и, очевидно, операция не должна быть выполнена).
6. Если пользователь введет слово exit — приложение завершит работу.
7. При вводе любой другой команды приложение выведет сообщение 
"Unsupported command. You can use commands: balance, deposit, withdrawal, exit".

## Solution

[Решение находится здесь!](https://github.com/MoJIoToK/learning_go/blob/master/module14/task_14.6.1.go)

1. Функция `intersectionWithDoubles()` принимает два входных параметра - два слайса и возвращает один слайс,
   содержащий повторяющиеся элементы. Здесь учитываются дубли которые могут попасться в массивах.
2. Функция `intersectionWithOutDoubles()` принимает два входных параметра - два слайса и возвращает один слайс,
   содержащий повторяющиеся элементы. Здесь не учитываются дубли которые могут попасться в массивах.
   Т.е. в результате будут записаны уникальные одинаковые элементы.
3. Заполнение слайсов происходит в методе `fillArray()`. Где входным параметром является размер слайса,
   а возвращаемым элементом является слайс типа `string`.

## Improvements

В качестве улучшений может быть реализовано следующее:

1. Создание `inputMap` размером равным размеру большего слайса. Но это не было реализовано,
   в связи с тем, что стандартной библиотекой не предусмотрена функция поиска максимального среди типов `int`.
   Конечно можно было бы реализовать это самостоятельно, но смысла захломлять код, я не вижу.